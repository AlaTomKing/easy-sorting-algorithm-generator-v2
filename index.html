<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>easy sorting algorithm generator v2</title>
  <style>
    html,
    body {
      margin: 0px;
      height: 100%
    }

    body {
      background: #000;
      width: 100%;
      height: 100%;
      padding: 5px;
      box-sizing: border-box;
      display: flex;
      flex-direction: row;
      justify-content: center;
      align-items: flex-end;
      overflow: hidden;
      gap: 1px;
    }

    div {
      width: 100%;
      /*min-width: 0px;*/
    }
  </style>
</head>

<body>

  <script>
    (() => {
      let arrayAccess = 0;
      let comparison = 0;

      const rainbow = false;
      const num = 128;
      const skipRandomize = true;
      const delay = 5; // IN MILLISECOND

      const random = (min, max) => {
        return Math.floor(Math.random() * (max - min + 1) + min)
      }

      // #region render pack
      let render_instruct = [];
      const colors = {
        default: "#fff",
        select: "#00f",
        compare: "#f00",
        swap: "#f0f",
        success: "#0f0",
      }

      const get_default_color = (idx) => {
        return () => {
          if (rainbow) {
            const el = render_elements[idx]
            return `hsl(${(el.style.height.substring(0, el.style.height.length - 1) / 100 * 360)}, 100%, 50%`;
          } else {
            return colors.default;
          }
        }
      }

      const get_other_color = (color) => {
        return () => {
          if (rainbow) {
            return colors.default;
          } else {
            return color
          }
        }
      }

      const render_default_both = (idx0, idx1) => {
        render_instruct.push({
          type: "multi",
          instruct: [{
            type: "color",
            index: idx0,
            value: get_default_color(idx0)
          }, {
            type: "color",
            index: idx1,
            value: get_default_color(idx1)
          }]
        })
      }

      const render_default = (idx) => {
        render_instruct.push({
          type: "color",
          index: idx,
          value: get_default_color(idx)
        })
      }

      const render_select = (idx) => {
        render_instruct.push({
          type: "color",
          index: idx,
          value: get_other_color(colors.select)
        })
      }

      const render_compare_both = (idx0, idx1) => {
        render_instruct.push({
          type: "multi",
          instruct: [{
            type: "color",
            index: idx0,
            value: get_other_color(colors.compare)
          }, {
            type: "color",
            index: idx1,
            value: get_other_color(colors.compare)
          }]
        })
      }

      const render_compare = (idx) => {
        render_instruct.push({
          type: "color",
          index: idx,
          value: get_other_color(colors.compare)
        })
      }

      const render_success = (idx) => {
        render_instruct.push({
          type: "color",
          index: idx,
          value: get_other_color(colors.success)
        })
      }

      const render_swap = (idx0, idx1) => {
        render_instruct.push({
          type: "multi",
          instruct: [
            {
              type: "color",
              index: idx0,
              value: get_other_color(colors.swap)
            },
            {
              type: "color",
              index: idx1,
              value: get_other_color(colors.swap)
            },
            {
              type: "swap",
              index0: idx0,
              index1: idx1
            }
          ]
        })

        render_instruct.push({
          type: "multi",
          instruct: [
            {
              type: "color",
              index: idx0,
              value: get_default_color(idx0)
            },
            {
              type: "color",
              index: idx1,
              value: get_default_color(idx1)
            },
          ]
        })
      }

      // #region easy starter pack
      let easy_array = [];
      let render_elements = [];

      const easy_create = (n) => {
        if (skipRandomize) {
          for (let i = 0; i < n; i++) {
            easy_array[i] = i + 1;
          }
          for (let i = 0; i < easy_array.length - 1; i++) {
            const randIdx = random(i + 1, easy_array.length - 1);
            const temp = easy_array[i];
            easy_array[i] = easy_array[randIdx];
            easy_array[randIdx] = temp;
          }
          for (let i = 0; i < n; i++) {
            const rect = document.createElement("div");
            if (rainbow)
              rect.setAttribute("style", `height: ${((easy_array[i]) / num) * 100}%; order: ${i}; background: hsl(${((i + 1) / num) * 360}, 100%, 50%)`);
            else
              rect.setAttribute("style", `height: ${((easy_array[i]) / num) * 100}%; order: ${i}; background: white`);
            document.querySelector("body").appendChild(rect);

            render_elements[i] = rect;
          }
        } else {
          for (let i = 0; i < n; i++) {
            easy_array[i] = i + 1;

            const rect = document.createElement("div");
            if (rainbow)
              rect.setAttribute("style", `height: ${((i + 1) / num) * 100}%; order: ${i}; background: hsl(${((i + 1) / num) * 360}, 100%, 50%)`);
            else
              rect.setAttribute("style", `height: ${((i + 1) / num) * 100}%; order: ${i}; background: white`);
            document.querySelector("body").appendChild(rect);

            render_elements[i] = rect;
          }
        }
      }

      const easy_loop = (min, max, func) => {
        for (let i = min; i <= max; i++) {
          render_select(i);
          func(i);
          render_default(i);
        }
      }

      const easy_success = (min, max, func) => {
        for (let i = min; i <= max; i++) {
          render_select(i);
          render_success(i);
        }
      }

      const easy_randomize = () => {

      }

      const easy_compare_great = (idx0, idx1) => { // compares if first value is greater than second value
        const compare = easy_array[idx0] > easy_array[idx1];
        render_compare(idx0);
        render_compare(idx1);
        if (!compare) {
          render_default_both(idx0, idx1);
        }
        return compare;
      }

      const easy_compare_less = (idx0, idx1) => { // compares if first value is greater than second value
        const compare = easy_array[idx0] < easy_array[idx1];
        render_compare(idx0);
        render_compare(idx1);
        if (!compare) {
          render_default_both(idx0, idx1);
        }
        return compare;
      }

      const easy_swap = (idx0, idx1) => {
        render_swap(idx0, idx1);
        const temp = easy_array[idx1];
        easy_array[idx1] = easy_array[idx0];
        easy_array[idx0] = temp;
      }

      const easy_run = () => {

      }
      // #endregion

      // #reigon algorithms
      const SELECTION_SORT = () => {

      }
      const BUBBLE_SORT = () => {

      }
      const INSERTION_SORT = () => {
        easy_loop(0, easy_array.length - 1, (i) => {
          let j = i;
          while (j > 0 && easy_compare_less(j, j - 1)) {
            easy_swap(j - 1, j)
            j--;
          }
        })
      }
      const MERGE_SORT = () => {
        const merge = () => {

        }

        const sort = () => {

        }
      }
      const SHELL_SORT = () => {

      }
      const COUNTING_SORT = () => {

      }
      const CYCLE_SORT = () => {

      }
      const GNOME_SORT = () => {

      }
      const COMB_SORT = () => {

      }
      const TIM_SORT = () => {

      }
      // #endregion

      const RANDOMIZE = () => {
        if (!skipRandomize)
          easy_loop(0, easy_array.length - 2, (i) => {
            const randIdx = random(i + 1, easy_array.length - 1)
            easy_swap(i, randIdx)
          })
      }

      const SUCCESS = () => {
        if (!rainbow)
          easy_success(0, easy_array.length - 1)
      }

      // #region animation

      // #endregion

      easy_create(num);
      //RANDOMIZE();
      //RANDOMIZE_SKIP();
      INSERTION_SORT();
      SUCCESS();
      console.log(render_instruct);

      const evaluate_instruction_inner = (instruction) => {
        switch (instruction.type) {
          case "color":
            const element0 = render_elements[instruction.index];
            element0.style.background = instruction.value();
            break;
          case "swap":
            const element1 = render_elements[instruction.index0];
            const element2 = render_elements[instruction.index1];
            const temp = element1.style.height
            element1.style.height = element2.style.height;
            element2.style.height = temp;
            break;
        }
      }

      const evaluate_instruction = (instruction) => {
        switch (instruction.type) {
          case "color": case "swap":
            evaluate_instruction_inner(instruction);
            break;
          case "multi":
            instruction.instruct.forEach((i) => {
              evaluate_instruction_inner(i);
            });
            break;
        }
      }

      const run_instructions = () => {
        const totalFrames = render_instruct.length;

        let startTime
        let runnin = false

        let then

        let previous = 0;

        const frame = () => {
          const now = performance.now();
          const totalTimeElapsed = performance.now() - startTime;
          const elapsed = now - then

          if (totalTimeElapsed < (totalFrames * delay) && runnin) {
            requestAnimationFrame(frame);

            if (elapsed > delay) {
              then = now - (elapsed % delay);
              const currentIdx = Math.floor(totalTimeElapsed / delay)
              if (currentIdx - previous > 1) {
                for (let i = previous + 1; i < currentIdx; i++) {
                  evaluate_instruction(render_instruct[i]);
                }
              }
              evaluate_instruction(render_instruct[currentIdx]);
              previous = currentIdx
            }
          } else {
            if (previous != render_instruct.length - 1) {
              for (let i = previous + 1; i < render_instruct.length; i++) {
                evaluate_instruction(render_instruct[i]);
              }
            }
            runnin = false;
          }
        }

        // function that will print out frames in 5 seconds
        const run = () => {
          if (render_instruct.length > 0)
            runnin = true

          startTime = performance.now();

          then = startTime;

          evaluate_instruction(render_instruct[0]);

          frame();
        }

        run();
      }

      run_instructions();
    })()
  </script>
</body>

</html>